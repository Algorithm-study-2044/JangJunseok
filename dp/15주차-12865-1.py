# 5:30 시작.

# 무게와 가치.
# 그러니까 두번째 물건을 넣을지 말지 고민할때.

# 기본적으로는 같은 무게의 가방에서 그 친구를 안넣었을때
# 그리고 그 친구를 같이 넣었을때

# 내가 생각하는 풀이는.
# 무게 n까지 두고. 

# item을 루프하면서, 1번 아이템부터. 넣고
# 2번 아이템. dp[k]는 무게 k일때의 최대 가치.

# k에서, 만약 남은 무게가, 해당 item까지 넣을 수 있따면?
# 그러면 그냥 넣어주고 아니면? 그러면 이제 비교해야함. 이걸 넣을지. 아니면 예를 뺄지

# 그런데 이 과정에서, 이걸 넣으려면, 기존의 것을 빼야하는데, 뭘 빼나?
# 그걸 모르잖아. 그러니까. 현재 j에서 weight만큼 뺐을때의 최대값을 알고,
# 그 최대값에다가 val을 더한거랑, 지금 현재 값이랑 비교하면 되는거 아니야?

# 그런데 이렇게 하면 일차원일때는 중복의 가능성이 생긴다. 다시말해 아이템을 두번 더해버리는 문제.
# 이거를 이차원 배열로 만들어주는 것.

# 근데 남은 무게를 몰라도 되는 이유는. 어차피 우리가 알고싶은거는 남은 무게가 얼마냐 이게 아니니까.
# 남은 무게에 상관없이. 그냥 얘를 넣을래 뺄래? 이거만 고민하면 되는것.

# 아니 남은 무게가 없으면 못넣는거 아닌가요? <-- 이게 내가 궁금했던 건데.
# 어차피 현재무게 - weight했을때 최대를 알면. 굳이 남은 무게를 몰라도, 무조건 넣을 수 있는 거니까.

# 그러면. dp[i-1][j-weight]와, dp[i-1][j]를 비교.

N,K = map(int,input().split())

items = []

for _ in range(N):
    items.append(list(map(int,input().split())))


dp = [[0]*(K+1) for _ in range(N+1)]

for i in range(1,N+1):
    weight,val = items[i-1]
    for j in range(1,K+1):
        if j >= weight:
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight]+val)
        # 이 부분도 추가해주어야 한다. 왜?     
        # 그 최대는 0이 아니라, 이걸 안넣었을때의 최대와 동일해야 하니까.
        else:
            dp[i][j] = dp[i-1][j]

print(dp[N][K])
