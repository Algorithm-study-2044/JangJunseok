# 11:20. 36ms. 54% beats. 

# 내가 막혔던 부분은, [2,7,9,3,1]에서, 2에서 9 1 가거나 2에서 3가거나. 그러면 그런 반복되는 로직을
# 또 다시 그 다음 연결되는 부분에서 해줘야 하는거 아니야? 그런 생각이 들어서.
# 그리디로는 해결하기 힘들다고 판단했다.

# 이건 그냥 생각을 바꾸면 되는 문제엿나? 정의 순서가 아니라, 역의 순서대로. 각 집의 입장에서,
# 이 집을 턴다고 했을때, 가장 최대가 되는 값은 얼마인가요?

# 나는 2에서, 2 9와 2 3을 비교했었다. 그런데 이렇게 하면, 또 뒤에 고려해줘야 하고
# 그런데 dp는, 이미 최적인 것을 계산해주니까. 그런 붑

class Solution:
    def rob(self, nums: List[int]) -> int:
        k = len(nums)
        dp = [0] * k

        if k == 1:
            return nums[0]

        dp[0] = nums[0]
        dp[1] = nums[1]

        for i in range(k):
            if i >= 2:
                dp[i] = dp[i-2] + nums[i]
            
            if i >= 3:
                dp[i] = max(dp[i-3] + nums[i], dp[i])

        # -3부터는 열등 조건이기때문에 고려할 필요가 없다.
        return max(dp[-1],dp[-2])